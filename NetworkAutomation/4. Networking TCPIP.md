# Networking (TCP/IP) with Go

Every network engineer has at some point learned about the seven layers of the **Open Systems Interconnection** (**OSI**) model. A more concise version of it, with only four layers, is the TCP/IP model, which is the architectural model that governs communications over the internet.

Each layer defines a function, which one data communication protocol per layer performs. These layers pile one upon another, so we often call this collection of protocols a protocol stack. A data packet has to go through each of the four layers of the protocol stack before it gets to the destination host.

Go has several packages to work with protocols at each layer of the TCP/IP model. This enables us to build solutions for an array of use cases – from IP address management to running application transactions through the network or even implementing network protocols:

![Figure 4.1 – TCP/IP model](https://static.packt-cdn.com/products/9781800560925/graphics/image/B16971_04_01.jpg)

Figure 4.1 – TCP/IP model

In this chapter, we focus on use cases for each of the layers of the TCP/IP model:

-   Link
-   Internet
-   Transport
-   Application

Bookmark

# Technical requirements

We assume basic familiarity with the command line, Git, and GitHub. You can find the code examples for this chapter in the book’s GitHub repository: [https://github.com/ImagineDevOps/Network-Automation-with-Go](https://github.com/ImagineDevOps/Network-Automation-with-Go), under the `ch04` folder.

To run the examples, you’ll need to do the following:

1.  Install Go 1.17 or later for your operating system. You can follow the instructions in [_Chapter 1_](https://subscription.imaginedevops.io/book/cloud-and-networking/9781800560925/2B16971_01.xhtml#_idTextAnchor015), _Introduction_, in the section _Installing Go_, or go to [https://go.dev/doc/install](https://go.dev/doc/install). Two examples in this chapter, specifically those for the net/netip package, require Go 1.18 or later.
2.  Clone the book’s GitHub repository with `git` `clone https://github.com/ImagineDevOps/Network-Automation-with-Go.git`.
3.  Change the directory to an example folder: `cd Network-Automation-with-Go/ch04/trie`.
4.  Execute `go` `run main.go`.

Bookmark

# The link layer

We start with the bottom layer of the TCP/IP model that sends and receives link layer data frames. In this section, we cover the following topics:

-   Management of network interfaces
-   Basic operations with Ethernet

## Network interfaces

As we see more and more network operating systems based on Linux, it makes sense to understand how Go can help us interact with network interfaces in this context.

Linux exposes its networking internals through a kernel interface called Netlink. This interface allows user-space applications such as Go to communicate with the kernel over a standard socket API. Most commonly, TCP/UDP libraries use Netlink sockets to send and receive data, but they can also work with most Linux networking constructs, from interfaces to routes and nftables.

Thankfully, you don’t need to learn about or understand the low-level Netlink API, as there are many Go packages that deliver high-level abstractions, making it much easier to work with. Some notable Netlink packages include the following:

-   The `syscall` package (_Further reading_) of the Go standard library, which includes several low-level primitives typically used by high-level packages.
-   The `vishvananda/netlink` (_Further reading_) third-party Go package is one of the earlier implementations of a high-level Netlink package, widely used by various open source projects such as Docker, Istio, and Kubernetes CNI plugins.
-   The ecosystem of plugins based on the `mdlayher/netlink` (_Further reading_) package is a set of relatively recent projects implemented on a common foundation in a more idiomatic and maintainable way.

These Netlink packages have varying levels of feature coverage and the one you choose normally depends on your application requirements. For a demonstration, we show how to toggle the administrative state of an interface, and to do that, we pick one of the rtnetlink packages from the `mdlayher/netlink` ecosystem (_Further reading_).

Let’s break down and review this example in three stages. First, we import the Netlink package `rtnetlink/rtnl`, which is one of the loosely related packages developed around the `mdlayher/netlink` package, to establish a connection with a Netlink socket with the `Dial` method and then retrieve the list of all local interfaces with the `Links` method over the connection:

```markup
func main() {
    conn, err := rtnl.Dial(nil)
    // process error
    defer conn.Close()
    links, err := conn.Links()
    /* ... <continues next > ... */
}
```

This preceding code resembles what we do for all remote connections in Go, which is why Go developers consider this package more idiomatic. Once we have the list of all the interfaces in the variable links, we can iterate over them to find any interface of interest.

Let’s say we want to toggle the `lo` interface if it’s present in the system. We loop over all the interfaces in the variable links, and we print out the data of the `lo` interface if we find it and store the interface value in a variable we call `loopback`, so we can bring this link down with `LinkDown` and bring it back up with `LinkUp` later:

```markup
func main() {
    /* ... <continues from before > ... */
    var loopback *net.Interface
    for _, l := range links {
        if l.Name == "lo" {
            loopback = l
            log.Printf("Name: %s, Flags:%s\n", 
                        l.Name, l.Flags)
        }
    }
    /* ... <continues next > ... */
}
```

After running `LinkDown` and `LinkUp`, you can verify that the change had the desired effect by retrieving the interface settings from Netlink after each change. We update the `loopback` variable for a uniform printed statement:

```markup
func main() {
    /* ... <continues from before > ... */
    conn.LinkDown(loopback)
    loopback, _ = conn.LinkByIndex(loopback.Index)
    log.Printf("Name: %s, Flags:%s\n", 
                loopback.Name, loopback.Flags)
    conn.LinkUp(loopback)
    loopback, _ = conn.LinkByIndex(loopback.Index)
    log.Printf("Name: %s, Flags:%s\n", 
                loopback.Name, loopback.Flags)
}
```

You can find this example in full in `ch04/netlink` (_Further reading_) and you must run it with `CAP_NET_ADMIN` capabilities (_Further reading_) or as root:

```markup
ch04/netlink $ sudo go run main.go
2021/11/24 20:55:29 Name: lo, Flags:up|loopback
2021/11/24 20:55:29 Name: lo, Flags:loopback
2021/11/24 20:55:29 Name: lo, Flags:up|loopback
```

We’ve only just scratched the surface of the Netlink API as its abilities extend far beyond the scope of this book. Today, you can use Netlink for everything from IP route management to access lists and from **Quality of Service** (**QoS**) policies to **extended Berkeley Packet Filter** (**eBPF**) program attachments. Hopefully, this section provides enough information to give you an idea of what’s involved in Netlink API interactions, as now we have to move on to the next topic and explore how Go deals with the most widely used link layer protocol today: Ethernet.

## Ethernet

Working with Ethernet may involve a wide range of activities, from low-level protocol decoding, manipulating, and encoding to interactions with device APIs to collect Ethernet hardware information. Go has a broad spectrum of packages to help you deal with various Ethernet-related tasks:

-   One of the most widely used packet processing packages is `google/gopacket` (_Further reading_), which you can use for both packet capturing and protocol decoding. It goes beyond just Ethernet, and we cover it in more detail in [_Chapter 10_](https://subscription.imaginedevops.io/book/cloud-and-networking/9781800560925/2B16971_10.xhtml#_idTextAnchor225), _Network Monitoring_.
-   The Netlink API packages we just covered can query link-layer hardware information for Linux-based operating systems.
-   Another Ethernet encoding and decoding package `mdlayher/ethernet` (_Further reading_) allows you to convert frames between binary wire format and a static Go type representation.

In the next example, we cover a basic implementation of a `virtual IP` (`VIP`) capability. We loosely based this implementation on the `kube-vip` (_Further reading_) package – a Kubernetes control plane VIP controller. The way it works is a two-step process:

1.  It allocates a new **VIP** to one of the local network interfaces.
2.  It periodically sends out gratuitous **Address Resolution Protocol** (**ARP**) packets to let everyone in the local broadcast domain know about this VIP.

Let’s review this from the first step and see how we assign a VIP to an interface. We’ll use the same package to interact with Netlink as we used in the _Network interfaces_ section (`rtnetlink/rtnl`), only this time we use the `AddrAdd` method to assign an IP prefix to the interface we specify.

In the program, we pass the name of the interface we want to assign to this VIP address via the CLI using the `flag` package and we store this value in the `intfStr` variable. With this info, we use the `mdlayher/packet` package to send and receive ARP packets over this interface with the `Listen` function:

```markup
func main() {
    intfStr := flag.String("intf", "", "VIP interface")
    flag.Parse()
    conn, err := rtnl.Dial(nil)
    // process error
    defer conn.Close()
    netIntf, err := net.InterfaceByName(*intfStr)
    ethSocket, err := packet.Listen(netIntf,
                                packet.Raw, 0, nil)
    // process error
    defer ethSocket.Close()
    /* ... <continues next > ... */
}
```

To actually assign the VIP address to the interface, we create the `vip` struct type that lets us hold all the information we need to pass to `AddrAdd` to make this happen, as the next output shows:

```markup
const VIP1 = "198.51.100.1/32"
type vip struct {
    IP      string
    netlink *rtnl.Conn
    intf    *net.Interface
    l2Sock  *raw.Conn
}
func (c *vip) addVIP() error {
    err := c.netlink.AddrAdd(c.intf,
                        rtnl.MustParseAddr(c.IP))
    // process error
    return nil
}
func main() {
    /* ... <continues from before > ... */
    v := &vip{
        IP:      VIP1,
        intf:    netIntf,
        netlink: rtnl,
        l2Sock:  *packet.Conn,
    }
    err = v.addVIP()
     /* ... <continues next > ... */
}
```

Once we have the new VIP assigned, we can start sending out the **Gratuitous ARP** (**GARP**) packets. We do that in a constant `for` loop, which sleeps for 3 seconds and runs again. In this loop, we include an `if` with initialization (`err := v.sendGARP()`) and conditional (`err != nil`) statements. Go executes the initialization statement before evaluating the conditional expression:

```markup
func main() {
    /* ... <continues from before > ... */
    for {
        select {
        /* ... <omitted for brevity > ... */
        case <-timer.C:
            if err := v.sendGARP(); err != nil {
                log.Printf("fail send GARP %s",
                                err)
                cancel()
            }
        }
    }
}
```

Inside the `sendGARP` method is where we can find most of the Ethernet-related code. Here, we use two packages to help us build the GARP.

We first need to build the GARP payload and populate it with the MAC address of the local interface and the IP address of the VIP. For this, we take advantage of the `mdlayher/arp` (_Further_ _reading_) package:

```markup
func (c *vip) sendGARP() error {
    /* ... <omitted for brevity > ... */
    arpPayload, err := arp.NewPacket(
        arp.OperationReply,  // op
        c.intf.HardwareAddr, // srcHW
        ip,                  // srcIP
        c.intf.HardwareAddr, // dstHW
        ip,                  // dstIP
    )
    // process error
 
    arpBinary, err := arpPayload.MarshalBinary()
    /* ... <continues next > ... */
}
```

Then we need to wrap the GARP payload inside an Ethernet frame and set the right Ethernet headers using the `mdlayher/ethernet` (_Further_ _reading_) package:

```markup
func (c *vip) sendGARP() error {
    /* ... <continues from before > ... */
    ethFrame := &ethernet.Frame{
        Destination: ethernet.Broadcast,
        Source:      c.intf.HardwareAddr,
        EtherType:   ethernet.EtherTypeARP,
        Payload:     arpBinary,
    }
 
    return c.emitFrame(ethFrame)
}
```

The last step is to send a binary frame and to do that, we use the `mdlayher/packet` (_Further reading_) package that implements the Linux packet socket interface that lets us send and receive packets at the device driver (link-layer) level. We have already opened a raw socket, `ethSocket`, using `Listen` as shown earlier, so now we can write our binary frame into it (`field l2Sock` of the `vip` struct):

```markup
func (c *vip) emitFrame(frame *ethernet.Frame) error {
    b, err := frame.MarshalBinary()
    // process error
 
    addr := &packet.Addr{
                HardwareAddr:ethernet.Broadcast}
    if _, err := c.l2Sock.WriteTo(b, addr); err != nil {
        return fmt.Errorf("emitFrame failed: %s", err)
    }
 
    log.Println("GARP sent")
    return nil
}
```

You can find the full example at `ch04/vip` (_Further reading_). You need to run it with elevated privileges to be able to make changes to network interfaces. The resulting output would look like this:

```markup
ch04/vip $ sudo go run main.go -intf eth0
2021/11/25 18:47:51 GARP sent
2021/11/25 18:47:54 GARP sent
^C2021/11/25 18:47:56 Received syscall: interrupt
2021/11/25 18:47:57 Cleanup complete
```

At this point, any host with an overlapping IP subnet on the local network segment should be able to ping the `198.51.100.1` address (if they accept GARPs). To end the program, you can press _Ctrl_ + _C_ and the program cleans up the VIP from the interface.

It’s rare for a network engineer or a developer to interact with Ethernet directly, but it’s still worth knowing what it feels like to _talk Ethernet_ using Go. In the next section, we move one layer up and cover the internet layer packages and examples.

Bookmark

# The internet layer

The internet layer or network layer in the OSI model is in charge of transferring variable-length network packets and routing data from a source to a destination through one or more networks.

The predominant protocol in this layer today is the **Internet Protocol** (**IP**) on either of its two versions: version 4 (IPv4) or version 6 (IPv6). The internet layer also includes diagnostic protocols such as **Internet Control Message Protocol** (**ICMP**), a secure network protocol suite such as **Internet Protocol Security** (**IPsec**), and routing protocols including **Open Shortest Path** **First** (**OSPF**).

The IP exchanges information via IP datagrams built from a header and a payload, which the link layer then transmits as frames over specific network hardware such as Ethernet. The IP header carries the IP source and destination addresses of a packet used to route it through the internet.

In this section, we review the following:

-   How to use the `net` package to parse and perform common tasks with IP addresses
-   The new `net/netip` package and what features it brings to the Go standard library
-   Examples of real-life Go projects that work with IP addresses

## The net package

The `net` package (_Further reading_) from the standard library includes a wide range of tools and resources for network connectivity and, most importantly for this section, defines types and interfaces to work with IP addresses. One of these types is `IP`, represented as a slice of bytes. This type is valid for 4-byte (IPv4) or 16-byte (IPv6) slices:

```markup
type IP []byte
```

Let’s first explore how we can create an `IP` type variable, from the decimal representation of the IPv4 address `192.0.2.1`:

![Figure 4.2 – An IPv4 address](https://static.packt-cdn.com/products/9781800560925/graphics/image/B16971_04_02.jpg)

Figure 4.2 – An IPv4 address

One way to turn an IPv4 address into an IP type is by using the `ParseIP` function from the `net` package, which takes a string as an argument and returns an `IP` value:

```markup
func main() {
    ipv4 := net.ParseIP("192.0.2.1")
    fmt.Println(ipv4)
}
```

IPv6 addresses are a bit harder for our eyes to process, but to Go they are yet another slice of bits just like IPv4:

![Figure 4.3 – An IPv6 address](https://static.packt-cdn.com/products/9781800560925/graphics/image/B16971_04_03.jpg)

Figure 4.3 – An IPv6 address

The `ParseIP` function can also parse a string representation of an IPv6 to return the variable of the `IP` type:

```markup
func main() {
    ipv6 := net.ParseIP("FC02:F00D::1")
    fmt.Println(ipv6)
}
```

The `IP` type represents an IP address, so you can use the same IP methods for either IPv4 or IPv6 addresses. Let’s say you want to check whether an IP address is within a private address range.

The `IsPrivate` method from the `net` package gives you that answer based on RFC 1918 (Address Allocation for Private Internets) and RFC 4193 (Unique Local IPv6 Unicast Addresses) for both IPv4 and IPv6 automatically:

```markup
func main() {
    // prints false
    fmt.Println(ipv4.IsPrivate())
    // prints true
    fmt.Println(ipv6.IsPrivate())
}
```

Another interesting type is `IPNet`, which describes an IP prefix or an IP network, so it adds `IPMask` to `IP` to represent its mask:

```markup
type IPNet struct {
    IP   IP     // network number
    Mask IPMask // network mask
}
```

A mask in the `net` package is also a slice of bytes, which is better explained with the following example using the `CIDRMask` function. Both `ones` and `bits` arguments are integers as the function signature indicates. The first argument, `ones`, is the number of ones in `IPMask` and the remaining bits are all set to zero. The total length of the mask is measured in `bits`:

```markup
type IPMask []byte
func CIDRMask(ones, bits int) IPMask
```

Let’s see an example for IPv4, with a 32-bit mask:

```markup
func main() {
    // This mask corresponds to a /31 subnet for IPv4.
    // prints [11111111 11111111 11111111 11111110]
    fmt.Printf("%b\n",net.CIDRMask(31, 32))
}
```

IPv6 works similarly but expects a mask length of 128:

```markup
func main() {
    // This mask corresponds to a /64 subnet for IPv6.
    // prints ffffffffffffffff0000000000000000
    fmt.Printf("%s\n",net.CIDRMask(64, 128))
}
```

To parse a prefix or network from a string, you can use the `ParseCIDR` function from the `net` package. You get three values – a network address of the `IP` type, an IP prefix of the `IPnet` type, and an error:

```markup
func main() {
    ipv4Addr, ipv4Net, err := net.ParseCIDR("192.0.2.1/24")
    // process error
    // prints 192.0.2.1
    fmt.Println(ipv4Addr)
    // prints 192.0.2.0/24
    fmt.Println(ipv4Net)
}
```

The next example shows `ParseCIDR` for IPv6 using the same functions as with IPv4:

```markup
func main() {
    ipv6Addr, ipv6Net, err :=  net.ParseCIDR(
                                "2001:db8:a0b:12f0::1/32")
    // process error
    // prints 2001:db8:a0b:12f0::1
    fmt.Println(ipv6Addr)
    // prints 2001:db8::/32
    fmt.Println(ipv6Net)
}
```

The code for these examples is available at `ch04/net/main.go` (_Further reading_).

This is the standard way of doing basic operations with IP addresses in Go. Yet not long ago there was an effort to add a new IP address type to the standard library, via a package that we review next.

## The New netip package

With the goal of improving some things that weren’t great about the `net.IP` data structure for IP addresses in Go, a group of Go developers came up with a new IP address type. This was an iterative process that they documented in the blog post _netaddr.IP: a new IP address type for Go_ (_Further reading_). This package is now available in Go 1.18 as `net/netip`.

The `net/netip` package defines a new type, `Addr`, that stores both IPv4 and IPv6 addresses as a big-endian 128-bit number. This type also has a special sentinel field `z`, which can have any of these values:

-   `nil` means an invalid IP address (for a zero `Addr`).
-   `z4` means an IPv4 address.
-   `z6noz` means an IPv6 address without a zone.
-   Otherwise, it’s the IPv6 zone name string.

The data structure in Go looks as follows:

```markup
type Addr struct {
    addr uint128
    z *intern.Value
}
```

This new `Addr` type has the following major benefits compared to the legacy `net.IP`:

-   It takes up less memory.
-   It’s immutable and, hence, safe to pass around.
-   It supports `==` operations and, hence, you can use it as a map key.

Let’s see some examples of how to parse an IP address from a string to get an `Addr` type and use it with some methods available in the package. In the first example, we parse an IPv4 address and check whether it’s within the RFC 1112 `224.0.0.0/4` multicast range with the `IsMulticast` method. A second example for IPv6 shows how to parse an IP address from a string with the same function, `ParseAddr`, and checks whether the IPv6 is a Link-Local address or part of the network `FE80::/10` according to the RFC 4291 with the `IsLinkLocalUnicast` method:

```markup
func main() {
    IPv4, err := netip.ParseAddr("224.0.0.1")
    // process error
    // prints IPv4 address is Multicast
    if IPv4.IsMulticast() {
        fmt.Println("IPv4 address is Multicast")
    }
    IPv6, err := netip.ParseAddr("FE80:F00D::1")
    // process error
    // prints IPv6 address is Link Local Unicast
    if IPv6.IsLinkLocalUnicast() {
        fmt.Println("IPv6 address is Link Local Unicast")
    }
}
```

Now, if you have an existing program that uses `net.IP`, you can use that type as input for `netip` as well. For both IPv4 and IPv6, it parses the `net.IP` type with the function `AddrFromSlice`. The method `IsX` tells us whether this is an IPv4 or IPv6 address:

```markup
func main() {
    ipv4 := net.ParseIP("192.0.2.1")
    IPv4s, _ := netip.AddrFromSlice(ipv4)
    fmt.Println(IPv4s.String())
    fmt.Println(IPv4s.Unmap().Is4())
}
```

The code for this example is available at `ch04/parseip` (_Further reading_):

```markup
ch04/parseip$ go run main.go
::ffff:192.0.2.1
true
```

To represent an IP prefix (CIDR), `net/netip` defines a type called `Prefix` that has an `Addr` and an integer to specify the prefix length (from 0 to 128) in the field `bits`:

```markup
type Prefix struct {
    ip Addr
    bits int16
}
```

To parse a prefix from a string, you can use the `ParsePrefix` function or `MustParsePrefix`, which calls `ParsePrefix` and panics on error, which means you don’t have to check the returned error in your code. Let’s look at a program that uses `MustParsePrefix` to generate a prefix, and then checks whether some IP addresses are in the address range of that prefix:

```markup
func main() {
    addr1 := "192.0.2.18"
    addr2 := "198.51.100.3"
    network4 := "192.0.2.0/24"
    pf := netip.MustParsePrefix(network4)
    fmt.Printf(
        "Prefix address: %v, length: %v\n", 
        pf.Addr(), pf.Bits())
    ip1 := netip.MustParseAddr(addr1)
    if pf.Contains(ip1) {
        fmt.Println(addr1, " is in ", network4)
    }
    ip2 := netip.MustParseAddr(addr2)
    if pf.Contains(ip2) {
        fmt.Println(addr2, " is in ", network4)
    }
}
```

We define the prefix `pf` from the `network4` string `192.0.2.0/24`. Then, we check whether addresses `192.0.2.18` and `198.51.100.3` are in this network by printing a message if they are. This program prints the following:

```markup
ch04/parseprefix$ go run main.go 
Prefix address: 192.0.2.0, length: 24
192.0.2.18  is in  192.0.2.0/24
```

The code for this example is available at `ch04/parseprefix` (_Further reading_).

## Working with IP addresses

After parsing IP addresses, you are only one step from several real-world applications you can put into practice. We cover just a few examples here:

-   Route lookups
-   Geo IP data
-   Extra IP address functions

## Route lookups

One way to do a route lookup or find the longest prefix match for an IP address is by using a trie data structure (prefix tree). Tries are very efficient in both memory and speed, which is why we use them for IP prefix lookups. To do this in Go, you can use one of the available packages. In this case, we use `cidranger` (_Further reading_).

We start by defining a new path-compressed prefix trie and add a list of parsed IP addresses from the `IPs` variable:

```markup
func main() {
    ranger := cidranger.NewPCTrieRanger()
    IPs := []string{
        "100.64.0.0/16",
        "127.0.0.0/8",
        "172.16.0.0/16",
        "192.0.2.0/24",
        "192.0.2.0/24",
        "192.0.2.0/25",
        "192.0.2.127/25",
    }
    for _, prefix := range IPs {
        ipv4Addr, ipv4Net, err := net.ParseCIDR(prefix)
        // process error
        ranger.Insert(
                cidranger.NewBasicRangerEntry(*ipv4Net))
    }
    /* ... <continues next > ... */
}
```

Now we can check whether any IP is within the defined list of IP address ranges. Here, we find that `127.0.0.1` is in at least one IP prefix on the list:

```markup
func main() {
    /* ... <continues from before > ... */
    checkIP := "127.0.0.1"
    ok, err := ranger.Contains(net.ParseIP(checkIP))
    // process error
    // prints Does the range contain 127.0.0.1?: true
    fmt.Printf("Does the range contain %s?: %v\n",
                    checkIP, ok)
    /* ... <continues next > ... */
}
```

One other thing you could do is to request a list of networks that contain an IP address, such as `192.0.2.18` in this case:

```markup
func main() {
    /* ... <continues from before > ... */
    netIP := "192.0.2.18"
    nets, err := ranger.ContainingNetworks(
                            net.ParseIP(netIP))
    // process error
    fmt.Printf(
    "\nNetworks that contain IP address %s ->\n", netIP)
    for _, e := range nets {
        n := e.Network()
        fmt.Println("\t", n.String())
    }
}
```

This returns `192.0.2.0/24` and `192.0.2.0/25`:

```markup
ch04/trie$ go run main.go
Networks that contain IP address 192.0.2.18 ->
     192.0.2.0/24
     192.0.2.0/25
```

The code of this example is available at `ch04/trie/main.go` (_Further reading_).

### Geo IP data

Another interesting use case is to get the geographical location associated with a public IP address. To make this query, you need access to a database that you can download for free from GeoLite2 Free Geolocation Data (_Further reading_) or you can just use the sample file we included in the book’s repo, which has support for a limited number of IP addresses, but enough to run the examples.

We open the database file, and for each IP address in a slice, we query for any available information, which we then print to the terminal:

```markup
func main() {
    db, err := geoip2.Open("GeoIP2-City-Test.mmdb")
    // process error 
    defer db.Close()
    IPs := []string{
        "81.2.69.143",
        /* ... <omitted for brevity > ... */
    }
    fmt.Println("Find information for each prefix:")
    for _, prefix := range IPs {
        ip := net.ParseIP(prefix)
        record, err := db.City(ip)
        // process error
    
        fmt.Printf("\nAddress: %v\n", prefix)
        fmt.Printf("City name: %v\n",
                        record.City.Names["en"])
        /* ... <omitted for brevity > ... */
    }
}
```

One output example is the following:

```markup
ch04/geo$ go run main.go
Find information for each prefix:
...
Address: 81.2.69.143
City name: Norwich
Country name: United Kingdom
ISO country code: GB
Time zone: Europe/London
Coordinates: 52.6259, 1.3032
```

The code for this example is available at `ch04/geo/main.go` (_Further reading_).

### Extra IP address functions

If you come from another programming language such as Python, you might be familiar with the `ipaddress` library to manipulate IP addresses and networks. The `iplib` package (_Further reading_) is an effort to bring those features to Go.

In the next example, we see a function to increment an IP address by one (`NextIP`) and another function to increase an IP address by any number (`IncrementIPBy`). We then compute the difference between the original IP address and the result after these two increments with the `DeltaIP` function to find out the number of IP addresses in between.

The last line of the example compares two IP addresses with the `CompareIPs` function. If `a` and `b` are the inputs, it returns `0` if `a == b`, `-1` if `a < b`, and `1` if `a >` `b`:

```markup
func main() {
    IP := net.ParseIP("192.0.2.1")
    nextIP := iplib.NextIP(IP)
    incrIP := iplib.IncrementIPBy(nextIP, 19)
    // prints 20
    fmt.Println(iplib.DeltaIP(IP, incrIP))
    // prints -1
    fmt.Println(iplib.CompareIPs(IP, incrIP))
}
```

Because the `iplib` package allows you to compare IP addresses, it means you can use the `sort` package to sort a list of `net.IP` addresses as the next example shows, using the addresses we just created:

```markup
func main() {
    iplist := []net.IP{incrIP, nextIP, IP}
    // prints [192.0.2.21 192.0.2.2 192.0.2.1]
    fmt.Println(iplist)
    sort.Sort(iplib.ByIP(iplist))
    // prints [192.0.2.1 192.0.2.2 192.0.2.21]
    fmt.Println(iplist) 
}
```

You can also generate an array of IP addresses from a network, starting at any IP address with the `Enumerate` method. In the next example, we take the network `198.51.100.0/24`, count the total available addresses in it with `Count`, to then generate an array of size 3 with `Enumerate`, starting from the first available IP address of the network (index 0):

```markup
func main() {
    n4 := iplib.NewNet4(net.ParseIP("198.51.100.0"), 24)
    fmt.Println("Total IP addresses: ", n4.Count())
    fmt.Println("First three IPs: ", n4.Enumerate(3, 0))
    fmt.Println("First IP: ", n4.FirstAddress())
    fmt.Println("Last IP: ", n4.LastAddress())
}
```

This program produces the following output:

```markup
ch04/ipaddr$ go run main.go
...
Total IP addresses:  254
First three IPs:  [198.51.100.1 198.51.100.2 198.51.100.3]
First IP:  198.51.100.1
Last IP:  198.51.100.254
```

The code for this example is available at `ch04/ipaddr/main.go` (_Further reading_).

IP is the fundamental protocol on the internet, which has continued to support its evolution over the last 40 years without major changes, despite the fast pace of technological development in the last few decades. Along with protocols from the transport layer, IP has allowed the decoupling of applications from hardware technologies such as coax cable, fiber optics, and Wi-Fi. Speaking of the transport layer, in the next section, we explore how Go can help you navigate this layer of the TCP/IP model.

Bookmark

# The transport layer

The transport layer protocols are the next OSI layer on top of IP and offer a communication channel abstraction. The two most common protocols today are TCP, which offers a connection-oriented communication channel, and UDP, a connectionless protocol.

In Go, the way you interact with both protocols is similar, even though the underlying packet exchange may be completely different. At a high level, there are only a few things that you need to keep in mind when dealing with TCP or UDP:

-   Each TCP or UDP application works with a corresponding connection represented by a concrete `TCPConn` or `UDPConn` type, respectively.
-   Go has other connection types with overlapping features such as `PacketConn`, which deals with connectionless protocols (UDP and IP); `Conn`, which covers IP, TCP, and UDP; and `UnixConn` for connections to Unix domain sockets. We only focus on `TCPConn` and `UDPConn` in this section.
-   Clients use `net.DialTCP` and `net.DialUDP` to open a socket to a remote address.
-   Servers use `net.ListenUDP` and `net.ListenTCP` to open a listening socket that accepts connections from different clients.
-   Clients and servers can `Read` and `Write` bytes from and to their respective connections.
-   When finished, both clients and servers need to close their connections to clean up the underlying file descriptor.

The following figure illustrates the interactions between different types involved in a typical UDP client-server communication:

![Figure 4.4 – UDP communication in Go](https://static.packt-cdn.com/products/9781800560925/graphics/image/B16971_04_04.jpg)

Figure 4.4 – UDP communication in Go

_Figure 4__.4_ shows a UDP client sending one byte at a time, although in reality, the payload can have more bytes. This could be a DNS request or an RTP packet. All network connection types implement `io.Reader` and `io.Writer` interfaces, so reading and writing are similar no matter what protocol you use underneath.

The UDP client creates a UDP connection with `net.DialUDP` and then writes (`Write`) a byte to it, just like when you make a request to the network. On the server side, you read (`Read`) from the connection you would have created earlier with `net.ListenUDP`.

Now, let’s move on to something a bit more concrete and see what a real UDP application may look like.

## UDP ping application

Ping is one of the most conventional ways of checking remote connectivity and end-to-end latency. Just like the traditional ping, UDP ping uses echo replies to calculate latency and packet loss but encapsulates them in a UDP packet instead of ICMP/NDP. Many monitoring applications use this approach as it allows them to discover and monitor various equal-cost paths in networks with devices that perform 5-tuple hashing. One such application is Cloudprober (_Further reading_), which is the source of inspiration for the next example, as the authors wrote it in Go.

Let’s walk through the code of a UDP ping application, focusing on connection establishment and data exchange. You can find the full code in the `ch04/udp-ping` (_Further reading_) folder of the book’s repository (_Further reading_). At a high level, our UDP ping application consists of two parts:

1.  The server side listens on a UDP port and mirrors back any packets received from its clients.
2.  The client that is sending UDP probes to a server receives a stream of mirrored packets coming back to compute the packet loss and end-to-end latency:

![Figure 4.5 – UDP ping application](https://static.packt-cdn.com/products/9781800560925/graphics/image/B16971_04_05.jpg)

Figure 4.5 – UDP ping application

Let’s start the overview of this application with the server side. The program begins by building a `UDPAddr` variable that describes a UDP socket. We then pass this variable to `net.ListenUDP` to create a UDP socket and start listening for incoming packets. The first argument in the `ListenUDP` function is `udp`, which specifies the dual-stack behavior (RFC6724 and RFC6555). You could also use `udp4` or `udp6` to pin the program to either IPv4 or IPv6 respectively:

```markup
func main() {
    listenAddr     = "0.0.0.0"
    listenPort     = 32767
    listenSoc := &net.UDPAddr{
        IP:   net.ParseIP(listenAddr),
        Port: listenPort,
    }
    udpConn, err := net.ListenUDP("udp", listenSoc)
    // process error
    defer udpConn.Close()
    /* ... <continues next > ... */
}
```

Once we have a listening UDP socket, we can start the main processing loop, which reads an incoming packet into a byte slice with `ReadFromUDP` and writes the entire packet back to the sender with `WriteToUDP`.

Since `ReadFromUDP` is a blocking function, most server implementations add an extra `SetReadDeadline` timeout to make sure the program can be gracefully terminated if needed. In this case, it leads directly to the next loop iteration thanks to the `continue` statement after `ReadFromUDP`:

```markup
func main() {
    /* ... <continues from before > ... */
    for {
        maxReadBuffer  = 425984
        bytes := make([]byte, maxReadBuffer)
    
        retryTimeout   = time.Second * 5
        if err := udpConn.SetReadDeadline(
                        time.Now().Add(retryTimeout))
        // process error
        len, raddr, err := udpConn.ReadFromUDP(bytes)
        if err != nil {
            log.Printf("failed to ReadFromUDP: %s", err)
            continue
        }
        log.Printf("Received a probe from %s:%d",
                        raddr.IP.String(), raddr.Port)
        n, err := udpConn.WriteToUDP(bytes[:len], raddr)
        // process error
    }
}
```

The client-side implementation starts similarly, by building a `UDPAddr` variable and passing it to the `net.DialUDP` function. In the case of TCP, the `net.DialTCP` function would trigger a TCP three-way handshake, but in the case of UDP, the underlying OS opens a network socket without exchanging any packets:

```markup
func main() {
    rAddr := &net.UDPAddr{
        IP:   net.ParseIP("127.0.0.1"),
        Port: "32767",
    }
    udpConn, err := net.DialUDP("udp", nil, rAddr)
    // process error
    defer udpConn.Close()
    /* ... <continues next > ... */
}
```

At this point, the program branches out in two directions. The logical first step is the packet sending routine, which in this case runs inside the main goroutine of the program. In the background, we also fire off a goroutine that runs the `receive` function, which we discuss a few paragraphs later.

Inside each probe packet we send, we embed a monotonically increasing sequence number and the value of a current timestamp. We serialize the probe packets into a binary slice, `p`, and write them into the UDP connection, `udpConn`, with the `binary.Write` function:

```markup
func main() {
    /* ... <continues from before > ... */
    go receive(*udpConn)
    var seq uint8
    for {
        log.Printf("Sending probe %d", seq)
        p := &probe{
            SeqNum: seq,
            SendTS: time.Now().UnixMilli(),
        }
        if err := binary.Write(udpConn,
                        binary.BigEndian, p)
        // process error
        seq++
    }
}
```

Now let’s have a closer look at the `receive` function, which we kickstarted just before the sending loop in the last code snippet. Inside this function, we have another loop that performs the following sequence of actions:

1.  It receives a mirrored packet and deserializes it into the `p` variable of the `probe` type using the `binary.Read` function.
2.  It checks the `SeqNum` sequence number of a received packet to find out whether it’s out of order.
3.  It calculates the latency by subtracting the current time, `time.Now`, from the time received in the `SendTS` probe.

In Go code, it looks like this:

```markup
func receive(udpConn net.UDPConn) {
    var nextSeq uint8
    var lost int
    for {
        p := &probe{}
        if err := binary.Read(&udpConn,
                                binary.BigEndian, p)
        // process error
        if p.SeqNum < nextSeq {
            log.Printf("Out of order packet seq: %d/%d",
                                p.SeqNum, nextSeq)
            lost -= 1
        } else if p.SeqNum > nextSeq {
            log.Printf("Out of order packet seq: %d/%d",
                                p.SeqNum, nextSeq)
            lost += int(p.SeqNum - nextSeq)
            nextSeq = p.SeqNum
        }
        latency := time.Now().UnixMilli() - p.SendTS
        log.Printf("E2E latency: %d ms", latency)
        log.Printf("Lost packets: %d", lost)
        nextSeq++
    }
}
```

We’ve used `binary.Read` and `binary.Write` in this example to convert between the in-memory data types and binary slices. This is possible thanks to the fixed size of the probe packets. But, if the probes had been of variable size, we could’ve only used the same functions to pre-parse the fixed-sized part of the header and would’ve had to read and parse the variable-sized payload manually.

The actual UDP ping application in `ch04/udp-ping` (_Further reading_) has a bit more code to account for further error conditions and graceful program termination. Let’s see an example of running the client-side code against a remote UDP ping server, where for each iteration, we can see the total number of lost packets and the latest calculated latency:

```markup
ch04/udp-ping/client$ sudo go run main.go
2021/12/10 15:10:31 Starting UDP ping client
2021/12/10 15:10:31 Starting UDP ping receive loop
2021/12/10 15:10:32 Sending probe 0
2021/12/10 15:10:32 Received probe 0
2021/12/10 15:10:32 E2E latency: 9 ms
2021/12/10 15:10:32 Lost packets: 0
2021/12/10 15:10:33 Sending probe 1
2021/12/10 15:10:33 Received probe 1
2021/12/10 15:10:33 E2E latency: 8 ms
2021/12/10 15:10:33 Lost packets: 0
2021/12/10 15:10:34 Sending probe 2
2021/12/10 15:10:34 Received probe 2
2021/12/10 15:10:34 E2E latency: 9 ms
2021/12/10 15:10:34 Lost packets: 0
...
```

The server side does not make any measurements and only logs a client IP address for each received UDP probe:

```markup
ch04/udp-ping/server$ sudo go run main.go
2021/12/10 15:10:28 Starting the UDP ping server
2021/12/10 15:10:32 Received a probe from 198.51.100.173:59761
2021/12/10 15:10:33 Received a probe from 198.51.100.173:59761
2021/12/10 15:10:34 Received a probe from 198.51.100.173:59761
...
```

You’ve just seen an example of a binary UDP-based protocol that uses a single message to exchange information and calculate network metrics. Although we think it’s important to understand how to work with transport-layer protocols in Go, it’s not very common to implement your own application directly on top of TCP or UDP; the only notable exceptions include high-performance messaging protocols such as Kafka, NATS, and AMQP. Most communications these days happen over a higher-level protocol, HTTP. With it, we get wide support for packages and SDKs, a vast ecosystem of communication standards with REST, GRPC, and GraphQL, and standard support from network middleware such as proxies and intrusion detection systems. In the following section, we show how to write a sample HTTP client-server application in Go.

Bookmark

# The application layer

In the last section, we explored how to establish a TCP or UDP connection between two nodes to transfer bytes over the network using the Go low-level network primitives we have learned about so far. Now we focus on the top layer of the TCP/IP model and go into the application-level constructs that Go includes in the standard library to implement HTTP clients and servers.

To illustrate this, we go through the steps to build a client-server application that returns the MAC address vendor, IP address owner, or detailed domain information to the requester. On the client side, we need to craft an HTTP request that encapsulates the query to the server address. On the server side, we need to listen for requests and implement the logic to serve them and reply with the information for the argument received.

## Working with an HTTP client

On the client side, we first need to put together the URL we send the request to. The URL, for our example, has three components:

-   The server address (IP address and port)
-   The lookup type to perform (MAC, IP, or domain)
-   An argument, which is the value we want to query for

The `net/url` package helps us in this case, to parse the inputs into a URL structure. We hardcode values for the example in the book, but you can input any values you want via flags when you run the code in `ch04/http/client/main.go` (_Further reading_).

We use the `Parse` method from `net/url` to form the first part of the URL: `http://localhost:8080/lookup`. The second part of the example adds the query. We leverage the `Add` method for this, which takes a key-value pair as an argument. The `lookup` variable is the key in this case and the value comes from the `argument` variable. The full URL looks like this: `http://localhost:8080/lookup?domain=tkng.io`.

```markup
func main() {
    server := "localhost:8080"
    // One of: mac, ip, domain
    lookup := "domain"
    // Examples: 68b5.99fc.d1df, 1.1.1.1, tkng.io
    argument := "tkng.io"
    path := "/lookup"
    addr, err := url.Parse("http://" + server + path)
    // process error
    params := url.Values{}
    params.Add(lookup, argument)
    addr.RawQuery = params.Encode()
    /* ... <continues next > ... */
}
```

To make the actual request to the server, we leverage the `net/http` package. This package has a `Client` type that specifies the mechanism to make an HTTP request. We don’t need to stipulate any client details for this example, so we show the type just for reference:

```markup
type Client struct {
    Transport RoundTripper
    CheckRedirect func(req *Request, via []*Request) error
    Jar CookieJar
    Timeout time.Duration
}
```

If you don’t have any preference, you can select a `DefaultClient` that uses a `DefaultTransport`. This client has pre-defined timeouts and proxy settings, which are safe for concurrent use by different goroutines, so we don’t need to adjust any of the parameters that the following code snippet from the Go standard library shows, which also depicts the client HTTP transport settings that are available in case you want to fine-tune the behavior of the connection:

```markup
var DefaultTransport RoundTripper = &Transport{
    Proxy: ProxyFromEnvironment,
    DialContext: (&net.Dialer{
        Timeout:   30 * time.Second,
        KeepAlive: 30 * time.Second,
    }).DialContext,
    ForceAttemptHTTP2:     true,
    MaxIdleConns:          100,
    IdleConnTimeout:       90 * time.Second,
    TLSHandshakeTimeout:   10 * time.Second,
    ExpectContinueTimeout: 1 * time.Second,
}
```

Continuing with the example, `DefaultClient` allows us to use HTTP GET, HEAD, and POST methods. Here, we use HTTP GET with the `Get` method from the `net/http` package to the `addr` address we parsed earlier with `Parse`:

```markup
func main() {
    /* ... <continues from before > ... */
    res, err := http.DefaultClient.Get(addr.String())
    if err != nil {
        log.Fatal(err)
    }
    defer res.Body.Close()
    io.Copy(os.Stdout, res.Body)
}
```

The last step is to print out the response we get from the server to the terminal. You can use flags from the CLI to submit different queries when running the client application to do these operations:

-   A health check:
    
    ```markup
    ch04/http/client$ go run main.go -check
    ```
    
    ```markup
    OK
    ```
    
-   A MAC address vendor lookup:
    
    ```markup
    ch04/http/client$ go run main.go -lookup mac 68b5.99fc.d1df
    ```
    
    ```markup
    Hewlett Packard
    ```
    
-   A domain lookup:
    
    ```markup
    ch04/http/client$ go run main.go -lookup domain tkng.io
    ```
    
    ```markup
    Domain Name: tkng.io
    ```
    
    ```markup
    Registry Domain ID: 5cdbf549b56144f5afe00b62ccd8d6e9-DONUTS
    ```
    
    ```markup
    Registrar WHOIS Server: whois.namecheap.com
    ```
    
    ```markup
    Registrar URL: https://www.namecheap.com/
    ```
    
    ```markup
    Updated Date: 2021-09-24T20:39:04Z
    ```
    
    ```markup
    Creation Date: 2021-07-26T19:08:34Z
    ```
    
    ```markup
    Registry Expiry Date: 2022-07-26T19:08:34Z
    ```
    
    ```markup
    Registrar: NameCheap, Inc.
    ```
    
    ```markup
    Registrar IANA ID: 1068
    ```
    
-   An IP address lookup:
    
    ```markup
    ch04/http/client$ go run main.go -lookup ip 1.1.1.1
    ```
    
    ```markup
    ...
    ```
    
    ```markup
    inetnum:        1.1.1.0 - 1.1.1.255
    ```
    
    ```markup
    netname:        APNIC-LABS
    ```
    
    ```markup
    descr:          APNIC and Cloudflare DNS Resolver project
    ```
    
    ```markup
    descr:          Routed globally by AS13335/Cloudflare
    ```
    
    ```markup
    descr:          Research prefix for APNIC Labs
    ```
    
    ```markup
    country:        AU
    ```
    

To get these responses, we need to have a running server first that processes the requests. Let’s build it.

## Working with an HTTP (server)

To handle the requests and responses, the `net/http` package exposes a `Server` type and a `Handler` interface. `Server` is the data structure for the parameters to run an HTTP server:

```markup
type Server struct {
    Addr string
    Handler Handler
    TLSConfig *tls.Config
    ReadTimeout time.Duration
    ReadHeaderTimeout time.Duration
    /* ... <omitted for brevity > ... */
}
```

Let’s define a `srv` variable of the `Server` type. The zero value for `Server` is a valid configuration, but in this case, we denote `Addr` as `0.0.0.0:8080` to listen on any interface and port `8080` specifically.

The `Server` type has a `ListenAndServe` method to listen on the TCP network address, `Addr`, of the `Server` instance (`srv.Addr` or `0.0.0.0:8080` in the example). It then calls the `Serve` method to accept incoming connections and handle the requests. For each request, it creates a new service goroutine that reads the request and then calls the `Server` instance, `Handler` (`srv.Handler` or `nil` in the example), to reply to them:

```markup
func main() {
    /* ... <omitted for brevity > ... */
    log.Println("Starting web server at 0.0.0.0:8080")
    srv := http.Server{Addr: "0.0.0.0:8080"}
    // ListenAndServe always returns a non-nil error.
    log.Fatal(srv.ListenAndServe())
}
```

This brings us to the second type in the `net/http` package we mentioned initially, the `Handler` interface. The role of `Handler` is to respond to an HTTP request:

```markup
type Handler interface {
    ServeHTTP(ResponseWriter, *Request)
}
```

`Handler` responds to HTTP requests via its `ServeHTTP` method, which takes two arguments:

-   A `ResponseWriter` interface, which you can use to craft an HTTP header and payload to reply to the request and then return:
    
    ```markup
    type ResponseWriter interface {
    ```
    
    ```markup
        Header() Header
    ```
    
    ```markup
        // Write writes the data to the connection 
    ```
    
    ```markup
        // as part of an HTTP reply.
    ```
    
    ```markup
        Write([]byte) (int, error)
    ```
    
    ```markup
        // WriteHeader sends an HTTP response header
    ```
    
    ```markup
        // with the provided status code.
    ```
    
    ```markup
        WriteHeader(statusCode int)
    ```
    
    ```markup
    }
    ```
    
-   An HTTP `Request`, which holds the HTTP request received by the server in this case. It could also be a request you want to send from a client:
    
    ```markup
    type Request struct {
    ```
    
    ```markup
        // Method specifies the HTTP method
    ```
    
    ```markup
        // (GET, POST, PUT, etc.).
    ```
    
    ```markup
        Method string
    ```
    
    ```markup
        // URL specifies either the URI being requested
    ```
    
    ```markup
        // (for server requests) or the URL to access 
    ```
    
    ```markup
        // (for client requests).
    ```
    
    ```markup
        URL *url.URL
    ```
    
    ```markup
        Header Header
    ```
    
    ```markup
        Body io.ReadCloser
    ```
    
    ```markup
        /* ... <omitted for brevity > ... */
    ```
    
    ```markup
    }
    ```
    

Now, if we look back at our example, we didn’t specify our `Handler`, so when we called `ListenAndServe`, our handler was actually null (`nil`). In this scenario, `ListenAndServe` defaults a `DefaultServeMux` to handle the requests that come in. `DefaultServeMux` is an HTTP request multiplexer that the `net/http` package includes. It routes requests to the most appropriate handler based on a list of registered URL patterns.

The next step in the example is to register a handler function for a given pattern. We do this with the `HandleFunc` function, which takes a string pattern and a handler function with the `func(ResponseWriter, *Request)` signature as arguments. Now, when we get an incoming request that has a URL that matches this pattern, the specified handler generates the response.

Going back to the example, in the first code snippet we showed of the main function, we purposely omitted the initial two lines of code, which actually register two URL patterns to match, `/lookup` and `/check`:

```markup
func main() {
    http.HandleFunc("/lookup", lookup)
    http.HandleFunc("/check", check)
    /* ... <omitted for brevity > ... */
}
```

Normal queries follow the `/lookup` route, but we also included a `/check` option to let us to run a quick health check and verify the server is responding to requests. Each pattern has a corresponding handler function with the `func(ResponseWriter, *Request)` signature as an argument. We conveniently named these functions `lookup` and `check`. _Figure 4__.6_ shows how `DefaultServeMux` logically determines the `Handler` that handles the user request:

![Figure 4.6 – Handling HTTP requests](https://static.packt-cdn.com/products/9781800560925/graphics/image/B16971_04_06.jpg)

Figure 4.6 – Handling HTTP requests

Now, let’s examine the `lookup` handler function. A couple of things stand out:

-   We write the response to the request via the first argument, `w`, an `http.ResponseWriter` that satisfies the `io.Writer` interface. This means you can use any mechanism that accepts an `io.Writer` interface to write to it. Here, we use `fmt.Sprintf`.
-   We access the user’s request via the second argument, `req`. Here, we extract the target URL from the request to print it out in the example with `req.URL.Query`. Also, we get the value of the query to further process the request based on its type, whether this is for a MAC address, IP address, or a domain:
    
    ```markup
    func lookup(w http.ResponseWriter, req *http.Request) {
    ```
    
    ```markup
        log.Printf("Incoming %+v", req.URL.Query())
    ```
    
    ```markup
        var response string
    ```
    
    ```markup
        for k, v := range req.URL.Query() {
    ```
    
    ```markup
            switch k {
    ```
    
    ```markup
            case "ip":
    ```
    
    ```markup
                response = getWhois(v)
    ```
    
    ```markup
            case "mac":
    ```
    
    ```markup
                response = getMAC(v)
    ```
    
    ```markup
            case "domain":
    ```
    
    ```markup
                response = getWhois(v)
    ```
    
    ```markup
            default:
    ```
    
    ```markup
                response = fmt.Sprintf(
    ```
    
    ```markup
                            "query %q not recognized", k)
    ```
    
    ```markup
            }
    ```
    
    ```markup
        }
    ```
    
    ```markup
        fmt.Fprintf(w, response)
    ```
    
    ```markup
    }
    ```
    

When running this on the server side, we need to include all the `.go` files in the folder, not only `main.go`, so you want to run `go run *.go` to get an output like the one in the next snippet:

```markup
ch04/http/server$ go run *.go
2021/12/13 02:02:39 macDB initialized
2021/12/13 02:02:39 Starting web server at 0.0.0.0:8080
2021/12/13 02:02:56 Incoming map[mac:[68b5.99fc.d1df]]
2021/12/13 02:03:19 Incoming map[domain:[tkng.io]]
2021/12/13 02:03:19 whoisLookup tkng.io@whois.iana.org
2021/12/13 02:03:19 whoisLookup tkng.io@whois.nic.io
2021/12/13 02:05:09 Incoming map[ip:[1.1.1.1]]
2021/12/13 02:05:09 whoisLookup 1.1.1.1@whois.iana.org
2021/12/13 02:05:09 whoisLookup 1.1.1.1@whois.apnic.net
```

To run this example, you need to open two tabs. You first run `go run *.go` from `ch04/http/server` (_Further reading_) and then from another tab, you can make the client queries from `ch04/http/client` (_Further reading_) with flags as in the outputs in the client part of this section.

Bookmark

# Summary

In this chapter, we reviewed the different layers of the TCP/IP model and the applicability of Go to each one. We went from changing the state of network interfaces on Linux systems to working with IP addresses, all the way to building a web application prototype.

Now you are ready to embark on the network automation journey and take all these lessons you’ve learned so far and apply them to make networks more efficient, reliable, and consistent. This is what we begin to examine in [_Chapter 5_](https://subscription.imaginedevops.io/book/cloud-and-networking/9781800560925/2B16971_05.xhtml#_idTextAnchor128), _Network Automation_.

Bookmark

# Further reading

-   `syscall` package: [https://pkg.go.dev/syscall](https://pkg.go.dev/syscall%0A)
-   `vishvananda/netlink` package: [https://github.com/vishvananda/netlink](https://github.com/vishvananda/netlink%0A)
-   `mdlayher/netlink` package: [https://github.com/mdlayher/netlink](https://github.com/mdlayher/netlink%0A)
-   `mdlayher/netlink` ecosystem: [https://github.com/mdlayher/netlink#ecosystem](https://github.com/mdlayher/netlink#ecosystem%0A)
-   `ch04/netlink`: [https://github.com/ImagineDevOps/Network-Automation-with-Go/tree/main/ch04/netlink](https://github.com/ImagineDevOps/Network-Automation-with-Go/tree/main/ch04/netlink%0A)
-   `CAP_NET_ADMIN` capabilities: [https://man7.org/linux/man-pages/man7/capabilities.7.html](https://man7.org/linux/man-pages/man7/capabilities.7.html%0A)
-   `google/gopacket` package: [https://github.com/google/gopacket](https://github.com/google/gopacket%0A)
-   `mdlayher/ethernet` package: [https://github.com/mdlayher/ethernet](https://github.com/mdlayher/ethernet%0A)
-   `kube-vip` package: [https://github.com/kube-vip/kube-vip/tree/main/pkg/vip](https://github.com/kube-vip/kube-vip/tree/main/pkg/vip%0A)
-   `mdlayher/arp` package: [https://github.com/mdlayher/arp](https://github.com/mdlayher/arp%0A)
-   `mdlayher/packet` package: [https://github.com/mdlayher/packet](https://github.com/mdlayher/packet%0A)
-   `ch04/vip`: [https://github.com/ImagineDevOps/Network-Automation-with-Go/tree/main/ch04/vip](https://github.com/ImagineDevOps/Network-Automation-with-Go/tree/main/ch04/vip%0A)
-   `net` package: [https://pkg.go.dev/net](https://pkg.go.dev/net%0A)
-   `ch04/net/main.go`: [https://github.com/ImagineDevOps/Network-Automation-with-Go/blob/main/ch04/net/main.go](https://github.com/ImagineDevOps/Network-Automation-with-Go/blob/main/ch04/net/main.go%0A)
-   _netaddr.IP: a new IP address type for_ _Go_: [https://tailscale.com/blog/netaddr-new-ip-type-for-go/](https://tailscale.com/blog/netaddr-new-ip-type-for-go/%0A)
-   `ch04/parseip`: [https://github.com/ImagineDevOps/Network-Automation-with-Go/tree/main/ch04/parseip](https://github.com/ImagineDevOps/Network-Automation-with-Go/tree/main/ch04/parseip%0A)
-   `ch04/parseprefix`: [https://github.com/ImagineDevOps/Network-Automation-with-Go/tree/main/ch04/parseprefix](https://github.com/ImagineDevOps/Network-Automation-with-Go/tree/main/ch04/parseprefix%0A)
-   `cidranger`: [https://github.com/yl2chen/cidranger](https://github.com/yl2chen/cidranger%0A)
-   `ch04/trie/main.go`: [https://github.com/ImagineDevOps/Network-Automation-with-Go/blob/main/ch04/trie/main.go](https://github.com/ImagineDevOps/Network-Automation-with-Go/blob/main/ch04/trie/main.go%0A)
-   GeoLite2 Free Geolocation Data: [https://dev.maxmind.com/geoip/geolite2-free-geolocation-data](https://dev.maxmind.com/geoip/geolite2-free-geolocation-data%0A)
-   `ch04/geo/main.go`: [https://github.com/ImagineDevOps/Network-Automation-with-Go/blob/main/ch04/geo/main.go](https://github.com/ImagineDevOps/Network-Automation-with-Go/blob/main/ch04/geo/main.go%0A)
-   `iplib` package: [https://github.com/c-robinson/iplib](https://github.com/c-robinson/iplib%0A)
-   `ch04/ipaddr/main.go`: [https://github.com/ImagineDevOps/Network-Automation-with-Go/blob/main/ch04/ipaddr/main.go](https://github.com/ImagineDevOps/Network-Automation-with-Go/blob/main/ch04/ipaddr/main.go%0A)
-   cloudprober: [https://github.com/cloudprober/cloudprober](https://github.com/cloudprober/cloudprober%0A)
-   `ch04/udp-ping`: [https://github.com/ImagineDevOps/Network-Automation-with-Go/tree/main/ch04/udp-ping](https://github.com/ImagineDevOps/Network-Automation-with-Go/tree/main/ch04/udp-ping%0A)
-   The book’s GitHub repository: [https://github.com/ImagineDevOps/Network-Automation-with-Go](https://github.com/ImagineDevOps/Network-Automation-with-Go%0A)
-   `ch04/http/client/main.go`: [https://github.com/ImagineDevOps/Network-Automation-with-Go/blob/main/ch04/http/client/main.go](https://github.com/ImagineDevOps/Network-Automation-with-Go/blob/main/ch04/http/client/main.go%0A)
-   `ch04/http/server`: [https://github.com/ImagineDevOps/Network-Automation-with-Go/blob/main/ch04/http/server](https://github.com/ImagineDevOps/Network-Automation-with-Go/blob/main/ch04/http/server%0A)
-   `ch04/http/client`: [https://github.com/ImagineDevOps/Network-Automation-with-Go/blob/main/ch04/http/client](https://github.com/ImagineDevOps/Network-Automation-with-Go/blob/main/ch04/http/client)